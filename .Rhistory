u <- round(rnorm(7,5,2),0)
u
v2 <- v1 + u
v2
gc1<-gc(peak =v1,
variance =c(2,2,1,1,1,1,1),
intensity = c(10,35,55,35,180,700,400),
window = c(3,3,3,5,5,10,10),
lowerlimit = 0,
upperlimit = 500)
# signal shifted by adding a random normal vector to the peak vectors
gc2<-gc(peak =v2,
variance =c(2,2,1,1,1,1,1),
intensity = c(10,35,55,35,180,700,400),
window = c(3,3,3,5,5,10,10),
lowerlimit = 0,
upperlimit = 500)
B1 <- gc1$print()
set.seed(1)
v1 <- c(50,110,140,175,190,230,250)
u <- round(rnorm(7,5,2),0)
u
v2 <- v1 + u
v2
gc1<-gc(peak =v1,
variance =c(2,2,1,1,1,1,1),
intensity = c(10,35,55,35,180,700,400),
window = c(3,3,3,5,5,10,10),
lowerlimit = 0,
upperlimit = 500)
# signal shifted by adding a random normal vector to the peak vectors
gc2<-gc(peak =v2,
variance =c(2,2,1,1,1,1,1),
intensity = c(10,35,55,35,180,700,400),
window = c(3,3,3,5,5,10,10),
lowerlimit = 0,
upperlimit = 500)
source("GC_Sim.R")
set.seed(1)
v1 <- c(50,110,140,175,190,230,250)
u <- round(rnorm(7,5,2),0)
u
v2 <- v1 + u
v2
gc1<-gc(peak =v1,
variance =c(2,2,1,1,1,1,1),
intensity = c(10,35,55,35,180,700,400),
window = c(3,3,3,5,5,10,10),
lowerlimit = 0,
upperlimit = 500)
# signal shifted by adding a random normal vector to the peak vectors
gc2<-gc(peak =v2,
variance =c(2,2,1,1,1,1,1),
intensity = c(10,35,55,35,180,700,400),
window = c(3,3,3,5,5,10,10),
lowerlimit = 0,
upperlimit = 500)
B1 <- gc1$print()
# signal shifted
T1 <- gc2$print()
plot(gc1$range(), B1, type = "l", col = "blue")
lines(gc1$range(),T1, col = "green")
P<-B1
Target <-T1
Lp <- max(P)-min(P)
Lt <- max(Target)-min(Target)
N <- Lp/m
Lp
Lt
P1
P
P <- round(P1,0)
P <- round(P1,0)
P1
P <- round(B12)
P <- round(B1,0)
Target <- round(T,0)
Lp <- max(P)-min(P)
Lt <- max(Target)-min(Target)
Lp
Lt
Target
T
T1
Target <- round(T1,0)
Lp <- max(P)-min(P)
Lt <- max(Target)-min(Target)
Lp
Lt
Target <- round(P1,0)
Target <- round(B1,0)
P <- round(T1,0)
Lp <- max(P)-min(P)
Lt <- max(Target)-min(Target)
Lp
Lt
m = 10
t = 3
N <- Lp/m
N
delta <- Lt/N - m
delta
Interval <- seq(delta-t,delta+t,1)
Interval
N <- round(Lp/m)
N
delta <- Lt/N - m
delta
delta <- round(Lt/N - m)
delta
delta <- Lt/N - m
delta
Interval <- seq(delta-t,delta+t,1)
nwarping <- length(Interval)
Lp <- max(P)-min(P)
Lt <- max(Target)-min(Target)
N
delta <- Lt/N - m
delta
nwarping
Interval
delta
min(P)
Lp <- max(P)-min(P)
Lp
Lt
N
delta <- Lt/N - m
delta
delta
delta <- round(Lt/N - m)
Interval <- seq(delta-t,delta+t,1)
Interval
nwarping <- length(Interval)
sapply(1:(N-1),function(i){ P[i] + m + u })
m
t
P[i]
P
N-1
sapply(1:(N-1),function(i){ P[i] + m + u })
P[i]
P[1]
m
u
1:nwarping
u
Interval
ui<-1
sapply(1:(N-1),function(i){ P[i] + m + Interval(ui) })
Lp <- max(P)-min(P)
Lt <- max(Target)-min(Target)
N <- round(Lp/m)
delta <- round(Lt/N - m)
Interval <- seq(delta-t,delta+t,1)
nwarping <- length(Interval)
sapply(1:(N-1),function(i){ P[i] + m + Interval(ui) })
sapply(1:(N-1),function(i){ P[i] + m + Interval[ui] })
m
Interval[ui]
delta
Interval
P
names(P)
x <- rownnames(P)
rownames(P
x <- rownames(P)
x
x <-names(P)
x
x <- names(P)
x
P
x <- 0:length(P)
x
sapply(1:(N-1),function(i){ x[i] + m + Interval[ui] })
x[i]
N
sapply(1:(N-1),function(i){ x[i] + m + Interval[ui] })
x
m
x[1]+10-Interval[1]
m
x[1]+10-Interval[1]
library("doParallel")
library(parallel)
n_cores <- detectCores(logical = TRUE)
cl <- makeCluster(n_cores - 1, type = "PSOCK")
registerDoParallel(cl)
all_samples<- as.data.frame(list.files(getwd))
list.files(getwd)
list.files(getwd())
as.data.frame(list.files(getwd()))
Warping <- function(x,i,u)
{
temp1 <- list()
temp1 <- f(x,Seg,u,Slack,Ix[i+1],Ix[i+2],X[,channel],T[,channel])
return(list(temp1= temp1))
}
?(...)
?clusterExport
>parLappky
?parLapply
Warping <- function(channel)
{
temp1 <- list()
temp1 <- f(x,Seg,u,Slack,Ix[i+1],Ix[i+2],X[,channel],T[,channel])
return(list(temp1= temp1))
}
clusterExport(cl,list('Warping','x','i','u','Seg','Slack','Ix','X','T'))
source("GC_Sim.R")
T1 = c(0,1,1,2,5,6,5,5,4,4,3,2,1,1,0,0)
X1 = c(0,0,1,1,1,2,3,5,5,6,6,5,3,1,1,0)
X2  = c(0,0,1,1,1,2,3,5,5,6,6,5,2,1,1,0)
slack = 1
Seg = 5
Slack = 1
Options = c(0,1,1,0,0)
# align signal X1
align(T1,X1,Seg,Slack)
Warping <- function(channel)
{
temp1 <- list()
temp1 <- f(x,Seg,u,Slack,Ix[i+1],Ix[i+2],X[,channel],T[,channel])
return(list(temp1= temp1))
}
if(!is.matrix(T)) T <- as.matrix(T)
if(!is.matrix(X)) X <- as.matrix(X)
# Pre-aligming length of chromatogram
# Intervals of 1 unit in P
Lx <- nrow(X)-1
# Post-aligning length of chromatogram and length of
# target chromatogram
Lt <- nrow(T)-1
# Calculate number of sections for X the query signal
N <- floor((Lx+1)/Seg)
T <-T1
X <- X1
if(!is.matrix(T)) T <- as.matrix(T)
if(!is.matrix(X)) X <- as.matrix(X)
# Pre-aligming length of chromatogram
# Intervals of 1 unit in P
Lx <- nrow(X)-1
# Post-aligning length of chromatogram and length of
# target chromatogram
Lt <- nrow(T)-1
# Calculate number of sections for X the query signal
N <- floor((Lx+1)/Seg)
# Ix sequence of node positions in X (query signal) before warping
Ix <- round(seq(1,(Lx+1) ,length.out = (N+1)))
temp = Lx %% Seg
# N number of sections and N + 1 nodes
Nnodes <- length(Ix)
if (Nnodes == N + 1)
{
if(Ix[Nnodes] != (Lx+1) ) Ix[Nnodes] <- Ix[Nnodes-1]+temp
} else if (N-1 - Nnodes == 1)
Ix[Nnodes + 1] <- Lx + 1
# calculate difference in mean section length between P and T
d <- floor(Lt/N) - Seg
F1 <- matrix(0.0, nrow = (N+1), ncol = Lt + 1)
U <- matrix(0.0, nrow = (N+1), ncol = Lt + 1)
for (i in 1:(N+1))
{
for(x in 1:(Lt + 1))
{
F1[i,x] <- -Inf
}
}
F1[N+1,] = 0
# W is the list that contain the warping signal for warping nodes
aux1W <- list()
temp1 <- list()
temp_unwarped <- list()
temp_warped <- list()
a <- rep(0, ncol(T)*nrow(T))
b <- rep(0, ncol(T)*nrow(T))
i <- N-1
#xstart: minimum start point of segment i in query signal
#xend: maximum end point of segment i in query signal
xstart <- max(1+i*(Seg+d-Slack),(Lt+1)-(N-i)*(Seg+d+Slack))
xend <- min(1+i*(Seg+d + Slack),(Lt+1)-(N-i)*(Seg+d-Slack))
cat("\n i=",i,"\\(", xstart, "-" ,xend, "\\) \n")
x <- start
d-Slack
u <- d-Slack
x+Seg+u <= Lt + 1
Lt
x
xstart
x <- xstart
x+Seg+u
n_cores <- detectCores(logical = TRUE)
cl <- makeCluster(n_cores - 1, type = "PSOCK")
registerDoParallel(cl)
clusterExport(cl,list('Warping','x','i','u','Seg','Slack','Ix','X','T'))
channel <- 1:ncol(X)
channel
tic("channel")
results <- c(parLapply(cl,'channel','x','i','u',fun = Warping))
toc()
clusterExport(cl,list('Warping','x','i','u','Seg','Slack','Ix','X','T'))
channel <- 1:ncol(X)
tic("channel")
results <- c(parLapply(cl,'channel','x','i','u',fun = Warping))
?parApply()
?parLapply
channel <- 1:ncol(X)
tic("channel")
results <- c(parLapply(cl,'channel',fun = Warping))
toc()
results
clusterExport(cl,list('Warping','x','i','u','Seg','Slack','Ix','X','T'))
channel <- 1:ncol(X)
tic("channel")
results <- c(parLapply(cl,'channel',fun = Warping))
clusterExport(cl,list('Warping','x','i','u','Seg','Slack','Ix','X','T','f'))
channel <- 1:ncol(X)
tic("channel")
results <- c(parLapply(cl,'channel',fun = Warping))
toc()
